{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Whipcream UI Classes Documentation Detail classes or structs implementation doc is here . \ud83e\udd2a Author Shota Shimazu","title":"Welcome"},{"location":"#whipcream-ui","text":"","title":"Whipcream UI"},{"location":"#classes-documentation","text":"Detail classes or structs implementation doc is here .","title":"Classes Documentation"},{"location":"#author","text":"Shota Shimazu","title":"\ud83e\udd2a  Author"},{"location":"04_Size/","text":"Size class Size class provides szie screen size utilities. Dangerous Absolute Sizes To get absolute screen size, use dangerousAbsoluteScreenWidth or dangerousAbsoluteScreenHeight properties. Danger This sizes is ABSOLUTE SCREEN SIZE that it is not recommended to use calculate layout. let screenWidth : CGFloat = Size . dangerousAbsoluteScreenWidth let screenHeight : CGFloat = Size . dangerousAbsoluteScreenHeight","title":"Size class"},{"location":"04_Size/#size-class","text":"Size class provides szie screen size utilities.","title":"Size class"},{"location":"04_Size/#dangerous-absolute-sizes","text":"To get absolute screen size, use dangerousAbsoluteScreenWidth or dangerousAbsoluteScreenHeight properties. Danger This sizes is ABSOLUTE SCREEN SIZE that it is not recommended to use calculate layout. let screenWidth : CGFloat = Size . dangerousAbsoluteScreenWidth let screenHeight : CGFloat = Size . dangerousAbsoluteScreenHeight","title":"Dangerous Absolute Sizes"},{"location":"Control/","text":"Whipcream Control State ON / OFF ON / OFF control state is alternative of boolean true or false. var isSomething : OnOff = . on // If you want yo get as a boolean value, do below ... if isSomethig . boolean { print ( \"Do something!\" ) } ...","title":"Whipcream Control State"},{"location":"Control/#whipcream-control-state","text":"","title":"Whipcream Control State"},{"location":"Control/#on-off","text":"ON / OFF control state is alternative of boolean true or false. var isSomething : OnOff = . on // If you want yo get as a boolean value, do below ... if isSomethig . boolean { print ( \"Do something!\" ) } ...","title":"ON / OFF"},{"location":"WhipLayoutStack/","text":"WhipLayoutStack WhipLayoutStack provides layout to views. It calculate position and size of UI. Here is an example for usage of WhipLayoutStack . // UI instances or definisions let scrollView = UIScrollView () let window = UIView () let heading = UILabel () let message = UILabel () let input = UITextField () let button = UIButton () override func viewDidLayoutSubviews () { super . viewDidLayoutSubviews () WhipLayoutStack ( root : view ) . size ( scrollView , width : view . bounds . width , height : view . bounds . height ) . auto ( window , top : view . bounds . height / 2 - 40 , bottom : 0 , right : 0 , left : 0 ) . frame ( heading , x : 0 , y : 40 , width : view . bounds . width , height : 65 ) . frame ( message , x : 0 , y : 138 , width : view . bounds . width , height : 30 ) . frame ( input , x : ( view . bounds . width - 355 ) / 2 , y : 258 , width : 355 , height : 67 ) } Without WhipLayoutStack , this process is generally written as follows. This example does not use AutoLayout. // UI instances or definisions let scrollView = UIScrollView () let window = UIView () let heading = UILabel () let message = UILabel () let input = UITextField () let button = UIButton () override func viewDidLayoutSubviews () { super . viewDidLayoutSubviews () scrollView . frame = CGRect ( x : 0 , y : 0 , width : view . bounds . width , height : view . bounds . height ) window . frame = CGRect ( x : 0 , y : view . bounds . height / 2 - 40 , width : view . bounds . width , height : view . bounds . height / 2 + 40 ) heading . frame = CGRect ( x : 0 , y : 40 , width : view . bounds . width , height : 65 ) message . frame = CGRect ( x : 0 , y : 138 , width : view . bounds . width , height : 30 ) input . frame = CGRect ( x : ( view . bounds . width - 355 ) / 2 , y : 258 , width : 355 , height : 67 ) }","title":"WhipLayoutStack"},{"location":"WhipLayoutStack/#whiplayoutstack","text":"WhipLayoutStack provides layout to views. It calculate position and size of UI. Here is an example for usage of WhipLayoutStack . // UI instances or definisions let scrollView = UIScrollView () let window = UIView () let heading = UILabel () let message = UILabel () let input = UITextField () let button = UIButton () override func viewDidLayoutSubviews () { super . viewDidLayoutSubviews () WhipLayoutStack ( root : view ) . size ( scrollView , width : view . bounds . width , height : view . bounds . height ) . auto ( window , top : view . bounds . height / 2 - 40 , bottom : 0 , right : 0 , left : 0 ) . frame ( heading , x : 0 , y : 40 , width : view . bounds . width , height : 65 ) . frame ( message , x : 0 , y : 138 , width : view . bounds . width , height : 30 ) . frame ( input , x : ( view . bounds . width - 355 ) / 2 , y : 258 , width : 355 , height : 67 ) } Without WhipLayoutStack , this process is generally written as follows. This example does not use AutoLayout. // UI instances or definisions let scrollView = UIScrollView () let window = UIView () let heading = UILabel () let message = UILabel () let input = UITextField () let button = UIButton () override func viewDidLayoutSubviews () { super . viewDidLayoutSubviews () scrollView . frame = CGRect ( x : 0 , y : 0 , width : view . bounds . width , height : view . bounds . height ) window . frame = CGRect ( x : 0 , y : view . bounds . height / 2 - 40 , width : view . bounds . width , height : view . bounds . height / 2 + 40 ) heading . frame = CGRect ( x : 0 , y : 40 , width : view . bounds . width , height : 65 ) message . frame = CGRect ( x : 0 , y : 138 , width : view . bounds . width , height : 30 ) input . frame = CGRect ( x : ( view . bounds . width - 355 ) / 2 , y : 258 , width : 355 , height : 67 ) }","title":"WhipLayoutStack"},{"location":"WhipViewStack/","text":"WhipViewStack WhipViewStack class realize composing or adding subviews structurally. Here is an example for usage of WhipViewStack . // UI instances or definisions let scrollView = UIScrollView () let window = UIView () let heading = UILabel () let message = UILabel () let input = UITextField () let button = UIButton () // Compose UI structure WhipViewStack ( root : view ) . add ( scrollView ) { view in WhipViewStack ( root : view ) . add ( self . window ) { win in WhipViewStack ( root : win ) . add ( self . heading ) . add ( self . message ) . add ( self . input ) . add ( self . button ) } } Without WhipViewStack , this process is generally written as follows. It is simple & easy to create a new UIView or inherited class instance and add its subview respectively. However, in large app, UI structure is too complicated to trace and manage UIs. Thus, using WLViewStack realize efficent UI composing. let scrollView = UIScrollView () view . addSubview ( scrollView ) let window = UIView () scrollView . addSubview ( window ) let heading = UILabel () window . addSubview ( heading ) let message = UILabel () window . addSubview ( message ) let input = UITextField () window . addSubview ( input ) let button = UIButton () window . addSubview ( button ) Deprecations WLViewStack has been renamed to WhipViewStack . WLayoutStack has been renamed to WLayoutStack .","title":"WhipViewStack"},{"location":"WhipViewStack/#whipviewstack","text":"WhipViewStack class realize composing or adding subviews structurally. Here is an example for usage of WhipViewStack . // UI instances or definisions let scrollView = UIScrollView () let window = UIView () let heading = UILabel () let message = UILabel () let input = UITextField () let button = UIButton () // Compose UI structure WhipViewStack ( root : view ) . add ( scrollView ) { view in WhipViewStack ( root : view ) . add ( self . window ) { win in WhipViewStack ( root : win ) . add ( self . heading ) . add ( self . message ) . add ( self . input ) . add ( self . button ) } } Without WhipViewStack , this process is generally written as follows. It is simple & easy to create a new UIView or inherited class instance and add its subview respectively. However, in large app, UI structure is too complicated to trace and manage UIs. Thus, using WLViewStack realize efficent UI composing. let scrollView = UIScrollView () view . addSubview ( scrollView ) let window = UIView () scrollView . addSubview ( window ) let heading = UILabel () window . addSubview ( heading ) let message = UILabel () window . addSubview ( message ) let input = UITextField () window . addSubview ( input ) let button = UIButton () window . addSubview ( button )","title":"WhipViewStack"},{"location":"WhipViewStack/#deprecations","text":"WLViewStack has been renamed to WhipViewStack . WLayoutStack has been renamed to WLayoutStack .","title":"Deprecations"},{"location":"install/carthage/","text":"Install using Carthage To install Whipcream UI , using Carthage or Cocoapods is recommended. Prepare Cartfile First, you need to create Cartfile in root dir of your project, unless you already created it. Then, define or register Whipcream , your Cartfile like here github \"shotastage/whipped-cream\" \"master\" Build framework Then, you build .framework using Carthage. In shortest way of building framework, following command is easy. $ carthage update whipped-cream Sometimes, Carthage failed to fetch or build frameworks. If you face to such trouble, try following command. $ carthage update --platform iOS --no-use-binaries --use-ssh --new-resolver whipped-cream","title":"Carthage"},{"location":"install/carthage/#install-using-carthage","text":"To install Whipcream UI , using Carthage or Cocoapods is recommended.","title":"Install using Carthage"},{"location":"install/carthage/#prepare-cartfile","text":"First, you need to create Cartfile in root dir of your project, unless you already created it. Then, define or register Whipcream , your Cartfile like here github \"shotastage/whipped-cream\" \"master\"","title":"Prepare Cartfile"},{"location":"install/carthage/#build-framework","text":"Then, you build .framework using Carthage. In shortest way of building framework, following command is easy. $ carthage update whipped-cream Sometimes, Carthage failed to fetch or build frameworks. If you face to such trouble, try following command. $ carthage update --platform iOS --no-use-binaries --use-ssh --new-resolver whipped-cream","title":"Build framework"},{"location":"install/cocoapods/","text":"Install using CocoaPods Currently, we does not support CocosPods. Please build framework manually or using Carthage .","title":"CocoaPods"},{"location":"install/cocoapods/#install-using-cocoapods","text":"Currently, we does not support CocosPods. Please build framework manually or using Carthage .","title":"Install using CocoaPods"},{"location":"layout/WhipLayoutStack/","text":"WhipLayoutStack WhipLayoutStack provides layout to views. It calculate position and size of UI. Here is an example for usage of WhipLayoutStack . // UI instances or definisions let scrollView = UIScrollView () let window = UIView () let heading = UILabel () let message = UILabel () let input = UITextField () let button = UIButton () override func viewDidLayoutSubviews () { super . viewDidLayoutSubviews () WhipLayoutStack ( root : view ) . size ( scrollView , width : view . bounds . width , height : view . bounds . height ) . auto ( window , top : view . bounds . height / 2 - 40 , bottom : 0 , right : 0 , left : 0 ) . frame ( heading , x : 0 , y : 40 , width : view . bounds . width , height : 65 ) . frame ( message , x : 0 , y : 138 , width : view . bounds . width , height : 30 ) . frame ( input , x : ( view . bounds . width - 355 ) / 2 , y : 258 , width : 355 , height : 67 ) } Without WhipLayoutStack , this process is generally written as follows. This example does not use AutoLayout. // UI instances or definisions let scrollView = UIScrollView () let window = UIView () let heading = UILabel () let message = UILabel () let input = UITextField () let button = UIButton () override func viewDidLayoutSubviews () { super . viewDidLayoutSubviews () scrollView . frame = CGRect ( x : 0 , y : 0 , width : view . bounds . width , height : view . bounds . height ) window . frame = CGRect ( x : 0 , y : view . bounds . height / 2 - 40 , width : view . bounds . width , height : view . bounds . height / 2 + 40 ) heading . frame = CGRect ( x : 0 , y : 40 , width : view . bounds . width , height : 65 ) message . frame = CGRect ( x : 0 , y : 138 , width : view . bounds . width , height : 30 ) input . frame = CGRect ( x : ( view . bounds . width - 355 ) / 2 , y : 258 , width : 355 , height : 67 ) }","title":"WhipLayoutStack"},{"location":"layout/WhipLayoutStack/#whiplayoutstack","text":"WhipLayoutStack provides layout to views. It calculate position and size of UI. Here is an example for usage of WhipLayoutStack . // UI instances or definisions let scrollView = UIScrollView () let window = UIView () let heading = UILabel () let message = UILabel () let input = UITextField () let button = UIButton () override func viewDidLayoutSubviews () { super . viewDidLayoutSubviews () WhipLayoutStack ( root : view ) . size ( scrollView , width : view . bounds . width , height : view . bounds . height ) . auto ( window , top : view . bounds . height / 2 - 40 , bottom : 0 , right : 0 , left : 0 ) . frame ( heading , x : 0 , y : 40 , width : view . bounds . width , height : 65 ) . frame ( message , x : 0 , y : 138 , width : view . bounds . width , height : 30 ) . frame ( input , x : ( view . bounds . width - 355 ) / 2 , y : 258 , width : 355 , height : 67 ) } Without WhipLayoutStack , this process is generally written as follows. This example does not use AutoLayout. // UI instances or definisions let scrollView = UIScrollView () let window = UIView () let heading = UILabel () let message = UILabel () let input = UITextField () let button = UIButton () override func viewDidLayoutSubviews () { super . viewDidLayoutSubviews () scrollView . frame = CGRect ( x : 0 , y : 0 , width : view . bounds . width , height : view . bounds . height ) window . frame = CGRect ( x : 0 , y : view . bounds . height / 2 - 40 , width : view . bounds . width , height : view . bounds . height / 2 + 40 ) heading . frame = CGRect ( x : 0 , y : 40 , width : view . bounds . width , height : 65 ) message . frame = CGRect ( x : 0 , y : 138 , width : view . bounds . width , height : 30 ) input . frame = CGRect ( x : ( view . bounds . width - 355 ) / 2 , y : 258 , width : 355 , height : 67 ) }","title":"WhipLayoutStack"},{"location":"layout/WhipViewStack/","text":"WhipViewStack WhipViewStack class realize composing or adding subviews structurally. Here is an example for usage of WhipViewStack . // UI instances or definisions let scrollView = UIScrollView () let window = UIView () let heading = UILabel () let message = UILabel () let input = UITextField () let button = UIButton () // Compose UI structure WhipViewStack ( root : view ) . add ( scrollView ) { view in WhipViewStack ( root : view ) . add ( self . window ) { win in WhipViewStack ( root : win ) . add ( self . heading ) . add ( self . message ) . add ( self . input ) . add ( self . button ) } } Without WhipViewStack , this process is generally written as follows. It is simple & easy to create a new UIView or inherited class instance and add its subview respectively. However, in large app, UI structure is too complicated to trace and manage UIs. Thus, using WLViewStack realize efficent UI composing. let scrollView = UIScrollView () view . addSubview ( scrollView ) let window = UIView () scrollView . addSubview ( window ) let heading = UILabel () window . addSubview ( heading ) let message = UILabel () window . addSubview ( message ) let input = UITextField () window . addSubview ( input ) let button = UIButton () window . addSubview ( button ) Deprecations WLViewStack has been renamed to WhipViewStack . WLayoutStack has been renamed to WLayoutStack .","title":"WhipViewStack"},{"location":"layout/WhipViewStack/#whipviewstack","text":"WhipViewStack class realize composing or adding subviews structurally. Here is an example for usage of WhipViewStack . // UI instances or definisions let scrollView = UIScrollView () let window = UIView () let heading = UILabel () let message = UILabel () let input = UITextField () let button = UIButton () // Compose UI structure WhipViewStack ( root : view ) . add ( scrollView ) { view in WhipViewStack ( root : view ) . add ( self . window ) { win in WhipViewStack ( root : win ) . add ( self . heading ) . add ( self . message ) . add ( self . input ) . add ( self . button ) } } Without WhipViewStack , this process is generally written as follows. It is simple & easy to create a new UIView or inherited class instance and add its subview respectively. However, in large app, UI structure is too complicated to trace and manage UIs. Thus, using WLViewStack realize efficent UI composing. let scrollView = UIScrollView () view . addSubview ( scrollView ) let window = UIView () scrollView . addSubview ( window ) let heading = UILabel () window . addSubview ( heading ) let message = UILabel () window . addSubview ( message ) let input = UITextField () window . addSubview ( input ) let button = UIButton () window . addSubview ( button )","title":"WhipViewStack"},{"location":"layout/WhipViewStack/#deprecations","text":"WLViewStack has been renamed to WhipViewStack . WLayoutStack has been renamed to WLayoutStack .","title":"Deprecations"}]}