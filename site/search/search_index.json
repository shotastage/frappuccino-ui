{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Whipcream UI Classes Documentation Detail classes or structs implementation doc is here . \ud83e\udd2a Author Shota Shimazu","title":"Whipcream UI"},{"location":"#whipcream-ui","text":"","title":"Whipcream UI"},{"location":"#classes-documentation","text":"Detail classes or structs implementation doc is here .","title":"Classes Documentation"},{"location":"#author","text":"Shota Shimazu","title":"\ud83e\udd2a  Author"},{"location":"01_Instalation/","text":"Installation To install Whipcream UI , using Carthage or Cocoapods is recommended. Carthage If you use Carthage, in your Cartfile is here github \"shotastage/whipped-cream\" \"master\" CocoaPods Currently, we does not support CocosPods. Please build framework manually or using Carthage .","title":"Installation"},{"location":"01_Instalation/#installation","text":"To install Whipcream UI , using Carthage or Cocoapods is recommended.","title":"Installation"},{"location":"01_Instalation/#carthage","text":"If you use Carthage, in your Cartfile is here github \"shotastage/whipped-cream\" \"master\"","title":"Carthage"},{"location":"01_Instalation/#cocoapods","text":"Currently, we does not support CocosPods. Please build framework manually or using Carthage .","title":"CocoaPods"},{"location":"02_WhipViewStack/","text":"WhipViewStack WhipViewStack class realize composing or adding subviews structurally. Here is an example for usage of WhipViewStack . // UI instances or definisions let scrollView = UIScrollView () let window = UIView () let heading = UILabel () let message = UILabel () let input = UITextField () let button = UIButton () // Compose UI structure WhipViewStack ( root : view ) . add ( scrollView ) { view in WhipViewStack ( root : view ) . add ( self . window ) { win in WhipViewStack ( root : win ) . add ( self . heading ) . add ( self . message ) . add ( self . input ) . add ( self . button ) } } Without WhipViewStack , this process is generally written as follows. It is simple & easy to create a new UIView or inherited class instance and add its subview respectively. However, in large app, UI structure is too complicated to trace and manage UIs. Thus, using WLViewStack realize efficent UI composing. let scrollView = UIScrollView () view . addSubview ( scrollView ) let window = UIView () scrollView . addSubview ( window ) let heading = UILabel () window . addSubview ( heading ) let message = UILabel () window . addSubview ( message ) let input = UITextField () window . addSubview ( input ) let button = UIButton () window . addSubview ( button ) Deprecations WLViewStack has been renamed to WhipViewStack . WLayoutStack has been renamed to WLayoutStack .","title":"WhipViewStack"},{"location":"02_WhipViewStack/#whipviewstack","text":"WhipViewStack class realize composing or adding subviews structurally. Here is an example for usage of WhipViewStack . // UI instances or definisions let scrollView = UIScrollView () let window = UIView () let heading = UILabel () let message = UILabel () let input = UITextField () let button = UIButton () // Compose UI structure WhipViewStack ( root : view ) . add ( scrollView ) { view in WhipViewStack ( root : view ) . add ( self . window ) { win in WhipViewStack ( root : win ) . add ( self . heading ) . add ( self . message ) . add ( self . input ) . add ( self . button ) } } Without WhipViewStack , this process is generally written as follows. It is simple & easy to create a new UIView or inherited class instance and add its subview respectively. However, in large app, UI structure is too complicated to trace and manage UIs. Thus, using WLViewStack realize efficent UI composing. let scrollView = UIScrollView () view . addSubview ( scrollView ) let window = UIView () scrollView . addSubview ( window ) let heading = UILabel () window . addSubview ( heading ) let message = UILabel () window . addSubview ( message ) let input = UITextField () window . addSubview ( input ) let button = UIButton () window . addSubview ( button )","title":"WhipViewStack"},{"location":"02_WhipViewStack/#deprecations","text":"WLViewStack has been renamed to WhipViewStack . WLayoutStack has been renamed to WLayoutStack .","title":"Deprecations"},{"location":"03_WhipLayoutStack/","text":"WhipLayoutStack WhipLayoutStack provides layout to views. It calculate position and size of UI. Here is an example for usage of WhipLayoutStack . // UI instances or definisions let scrollView = UIScrollView () let window = UIView () let heading = UILabel () let message = UILabel () let input = UITextField () let button = UIButton () override func viewDidLayoutSubviews () { super . viewDidLayoutSubviews () WhipLayoutStack ( root : view ) . size ( scrollView , width : view . bounds . width , height : view . bounds . height ) . auto ( window , top : view . bounds . height / 2 - 40 , bottom : 0 , right : 0 , left : 0 ) . frame ( heading , x : 0 , y : 40 , width : view . bounds . width , height : 65 ) . frame ( message , x : 0 , y : 138 , width : view . bounds . width , height : 30 ) . frame ( input , x : ( view . bounds . width - 355 ) / 2 , y : 258 , width : 355 , height : 67 ) } Without WhipLayoutStack , this process is generally written as follows. This example does not use AutoLayout. // UI instances or definisions let scrollView = UIScrollView () let window = UIView () let heading = UILabel () let message = UILabel () let input = UITextField () let button = UIButton () override func viewDidLayoutSubviews () { super . viewDidLayoutSubviews () scrollView . frame = CGRect ( x : 0 , y : 0 , width : view . bounds . width , height : view . bounds . height ) window . frame = CGRect ( x : 0 , y : view . bounds . height / 2 - 40 , width : view . bounds . width , height : view . bounds . height / 2 + 40 ) heading . frame = CGRect ( x : 0 , y : 40 , width : view . bounds . width , height : 65 ) message . frame = CGRect ( x : 0 , y : 138 , width : view . bounds . width , height : 30 ) input . frame = CGRect ( x : ( view . bounds . width - 355 ) / 2 , y : 258 , width : 355 , height : 67 ) }","title":"WhipLayoutStack"},{"location":"03_WhipLayoutStack/#whiplayoutstack","text":"WhipLayoutStack provides layout to views. It calculate position and size of UI. Here is an example for usage of WhipLayoutStack . // UI instances or definisions let scrollView = UIScrollView () let window = UIView () let heading = UILabel () let message = UILabel () let input = UITextField () let button = UIButton () override func viewDidLayoutSubviews () { super . viewDidLayoutSubviews () WhipLayoutStack ( root : view ) . size ( scrollView , width : view . bounds . width , height : view . bounds . height ) . auto ( window , top : view . bounds . height / 2 - 40 , bottom : 0 , right : 0 , left : 0 ) . frame ( heading , x : 0 , y : 40 , width : view . bounds . width , height : 65 ) . frame ( message , x : 0 , y : 138 , width : view . bounds . width , height : 30 ) . frame ( input , x : ( view . bounds . width - 355 ) / 2 , y : 258 , width : 355 , height : 67 ) } Without WhipLayoutStack , this process is generally written as follows. This example does not use AutoLayout. // UI instances or definisions let scrollView = UIScrollView () let window = UIView () let heading = UILabel () let message = UILabel () let input = UITextField () let button = UIButton () override func viewDidLayoutSubviews () { super . viewDidLayoutSubviews () scrollView . frame = CGRect ( x : 0 , y : 0 , width : view . bounds . width , height : view . bounds . height ) window . frame = CGRect ( x : 0 , y : view . bounds . height / 2 - 40 , width : view . bounds . width , height : view . bounds . height / 2 + 40 ) heading . frame = CGRect ( x : 0 , y : 40 , width : view . bounds . width , height : 65 ) message . frame = CGRect ( x : 0 , y : 138 , width : view . bounds . width , height : 30 ) input . frame = CGRect ( x : ( view . bounds . width - 355 ) / 2 , y : 258 , width : 355 , height : 67 ) }","title":"WhipLayoutStack"},{"location":"04_Size/","text":"Size class Size class provides szie screen size utilities. Dangerous Absolute Sizes To get absolute screen size, use dangerousAbsoluteScreenWidth or dangerousAbsoluteScreenHeight properties. Danger This sizes is ABSOLUTE SCREEN SIZE that it is not recommended to use calculate layout. let screenWidth : CGFloat = Size . dangerousAbsoluteScreenWidth let screenHeight : CGFloat = Size . dangerousAbsoluteScreenHeight","title":"Size class"},{"location":"04_Size/#size-class","text":"Size class provides szie screen size utilities.","title":"Size class"},{"location":"04_Size/#dangerous-absolute-sizes","text":"To get absolute screen size, use dangerousAbsoluteScreenWidth or dangerousAbsoluteScreenHeight properties. Danger This sizes is ABSOLUTE SCREEN SIZE that it is not recommended to use calculate layout. let screenWidth : CGFloat = Size . dangerousAbsoluteScreenWidth let screenHeight : CGFloat = Size . dangerousAbsoluteScreenHeight","title":"Dangerous Absolute Sizes"},{"location":"Control/","text":"Whipcream Control State ON / OFF ON / OFF control state is alternative of boolean true or false. var isSomething : OnOff = . on // If you want yo get as a boolean value, do below ... if isSomethig . boolean { print ( \"Do something!\" ) } ...","title":"Whipcream Control State"},{"location":"Control/#whipcream-control-state","text":"","title":"Whipcream Control State"},{"location":"Control/#on-off","text":"ON / OFF control state is alternative of boolean true or false. var isSomething : OnOff = . on // If you want yo get as a boolean value, do below ... if isSomethig . boolean { print ( \"Do something!\" ) } ...","title":"ON / OFF"},{"location":"WhipLayoutStack/","text":"WhipLayoutStack WhipLayoutStack provides layout to views. It calculate position and size of UI. Here is an example for usage of WhipLayoutStack . // UI instances or definisions let scrollView = UIScrollView () let window = UIView () let heading = UILabel () let message = UILabel () let input = UITextField () let button = UIButton () override func viewDidLayoutSubviews () { super . viewDidLayoutSubviews () WhipLayoutStack ( root : view ) . size ( scrollView , width : view . bounds . width , height : view . bounds . height ) . auto ( window , top : view . bounds . height / 2 - 40 , bottom : 0 , right : 0 , left : 0 ) . frame ( heading , x : 0 , y : 40 , width : view . bounds . width , height : 65 ) . frame ( message , x : 0 , y : 138 , width : view . bounds . width , height : 30 ) . frame ( input , x : ( view . bounds . width - 355 ) / 2 , y : 258 , width : 355 , height : 67 ) } Without WhipLayoutStack , this process is generally written as follows. This example does not use AutoLayout. // UI instances or definisions let scrollView = UIScrollView () let window = UIView () let heading = UILabel () let message = UILabel () let input = UITextField () let button = UIButton () override func viewDidLayoutSubviews () { super . viewDidLayoutSubviews () scrollView . frame = CGRect ( x : 0 , y : 0 , width : view . bounds . width , height : view . bounds . height ) window . frame = CGRect ( x : 0 , y : view . bounds . height / 2 - 40 , width : view . bounds . width , height : view . bounds . height / 2 + 40 ) heading . frame = CGRect ( x : 0 , y : 40 , width : view . bounds . width , height : 65 ) message . frame = CGRect ( x : 0 , y : 138 , width : view . bounds . width , height : 30 ) input . frame = CGRect ( x : ( view . bounds . width - 355 ) / 2 , y : 258 , width : 355 , height : 67 ) }","title":"WhipLayoutStack"},{"location":"WhipLayoutStack/#whiplayoutstack","text":"WhipLayoutStack provides layout to views. It calculate position and size of UI. Here is an example for usage of WhipLayoutStack . // UI instances or definisions let scrollView = UIScrollView () let window = UIView () let heading = UILabel () let message = UILabel () let input = UITextField () let button = UIButton () override func viewDidLayoutSubviews () { super . viewDidLayoutSubviews () WhipLayoutStack ( root : view ) . size ( scrollView , width : view . bounds . width , height : view . bounds . height ) . auto ( window , top : view . bounds . height / 2 - 40 , bottom : 0 , right : 0 , left : 0 ) . frame ( heading , x : 0 , y : 40 , width : view . bounds . width , height : 65 ) . frame ( message , x : 0 , y : 138 , width : view . bounds . width , height : 30 ) . frame ( input , x : ( view . bounds . width - 355 ) / 2 , y : 258 , width : 355 , height : 67 ) } Without WhipLayoutStack , this process is generally written as follows. This example does not use AutoLayout. // UI instances or definisions let scrollView = UIScrollView () let window = UIView () let heading = UILabel () let message = UILabel () let input = UITextField () let button = UIButton () override func viewDidLayoutSubviews () { super . viewDidLayoutSubviews () scrollView . frame = CGRect ( x : 0 , y : 0 , width : view . bounds . width , height : view . bounds . height ) window . frame = CGRect ( x : 0 , y : view . bounds . height / 2 - 40 , width : view . bounds . width , height : view . bounds . height / 2 + 40 ) heading . frame = CGRect ( x : 0 , y : 40 , width : view . bounds . width , height : 65 ) message . frame = CGRect ( x : 0 , y : 138 , width : view . bounds . width , height : 30 ) input . frame = CGRect ( x : ( view . bounds . width - 355 ) / 2 , y : 258 , width : 355 , height : 67 ) }","title":"WhipLayoutStack"},{"location":"WhipViewStack/","text":"WhipViewStack WhipViewStack class realize composing or adding subviews structurally. Here is an example for usage of WhipViewStack . // UI instances or definisions let scrollView = UIScrollView () let window = UIView () let heading = UILabel () let message = UILabel () let input = UITextField () let button = UIButton () // Compose UI structure WhipViewStack ( root : view ) . add ( scrollView ) { view in WhipViewStack ( root : view ) . add ( self . window ) { win in WhipViewStack ( root : win ) . add ( self . heading ) . add ( self . message ) . add ( self . input ) . add ( self . button ) } } Without WhipViewStack , this process is generally written as follows. It is simple & easy to create a new UIView or inherited class instance and add its subview respectively. However, in large app, UI structure is too complicated to trace and manage UIs. Thus, using WLViewStack realize efficent UI composing. let scrollView = UIScrollView () view . addSubview ( scrollView ) let window = UIView () scrollView . addSubview ( window ) let heading = UILabel () window . addSubview ( heading ) let message = UILabel () window . addSubview ( message ) let input = UITextField () window . addSubview ( input ) let button = UIButton () window . addSubview ( button ) Deprecations WLViewStack has been renamed to WhipViewStack . WLayoutStack has been renamed to WLayoutStack .","title":"WhipViewStack"},{"location":"WhipViewStack/#whipviewstack","text":"WhipViewStack class realize composing or adding subviews structurally. Here is an example for usage of WhipViewStack . // UI instances or definisions let scrollView = UIScrollView () let window = UIView () let heading = UILabel () let message = UILabel () let input = UITextField () let button = UIButton () // Compose UI structure WhipViewStack ( root : view ) . add ( scrollView ) { view in WhipViewStack ( root : view ) . add ( self . window ) { win in WhipViewStack ( root : win ) . add ( self . heading ) . add ( self . message ) . add ( self . input ) . add ( self . button ) } } Without WhipViewStack , this process is generally written as follows. It is simple & easy to create a new UIView or inherited class instance and add its subview respectively. However, in large app, UI structure is too complicated to trace and manage UIs. Thus, using WLViewStack realize efficent UI composing. let scrollView = UIScrollView () view . addSubview ( scrollView ) let window = UIView () scrollView . addSubview ( window ) let heading = UILabel () window . addSubview ( heading ) let message = UILabel () window . addSubview ( message ) let input = UITextField () window . addSubview ( input ) let button = UIButton () window . addSubview ( button )","title":"WhipViewStack"},{"location":"WhipViewStack/#deprecations","text":"WLViewStack has been renamed to WhipViewStack . WLayoutStack has been renamed to WLayoutStack .","title":"Deprecations"}]}